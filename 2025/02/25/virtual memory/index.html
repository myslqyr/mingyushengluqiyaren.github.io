<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="myslqyr">





<title>5.virtual memory | myslqyr&#39;s blog</title>



    <link rel="icon" href="/favicon1.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">myslqyr&#39;s blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">myslqyr&#39;s blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">5.virtual memory</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">myslqyr</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 25, 2025&nbsp;&nbsp;20:48:06</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/os/">os</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="内核4-虚拟内存"><a href="#内核4-虚拟内存" class="headerlink" title="内核4 虚拟内存"></a>内核4 虚拟内存</h1><p>qemu共配置了128M的内存，在之前的代码中，boot被放在了0x7c00处，loader放在了0x8000处，kernel放在了0x10000处（由Cmake来指定），所以还剩下127M左右的内存没有进行使用。操作系统有一个重要职责是决定如何管理计算机中的整块内存。具体的职责有以下几点。<br><img src="/2025/02/25/virtual%20memory/1.jpg" alt="1.jpg"><br>内存中存在多个进程时，加载进程会存在一些问题，比如要将进程加载到内存中的哪个区域，如何分配和回收内存。这时可以用到虚拟内存来对内存空间进行管理。x86虚拟内存管理硬件将内存看组成相同大小的页，即分页机制。进程看到的存储空间是连续的，但是经过页表的转换后就会将页帧分配到内存中，即将虚拟内存映射到物理内存中。</p>
<h3 id="内存的分配和释放"><a href="#内存的分配和释放" class="headerlink" title="内存的分配和释放"></a>内存的分配和释放</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>我们如何知道内存中的一个页是否被使用呢？显而易见的一个方法就是bitmap，页被使用则在位图相应位置中置一，未被使用则置零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bitmap_g</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit_count; <span class="comment">// 位的数据</span></span><br><span class="line">    <span class="type">uint8_t</span> *bits; <span class="comment">// 位空间</span></span><br><span class="line">&#125; <span class="type">bitmap_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_byte_count</span><span class="params">(<span class="type">int</span> bit_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (bit_count + <span class="number">8</span> - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">uint8_t</span> *bits, <span class="type">int</span> count, <span class="type">int</span> init_bit)</span></span><br><span class="line">&#123;</span><br><span class="line">    bitmap-&gt;bit_count = count;</span><br><span class="line">    bitmap-&gt;bits = bits;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bytes = bitmap_byte_count(bitmap-&gt;bit_count);</span><br><span class="line">    kernel_memset(bitmap-&gt;bits, init_bit ? <span class="number">0xFF</span> : <span class="number">0</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了位图的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitmap_get_bit</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span>;    <span class="comment">//获取位图中某一个位的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set_bit</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index, <span class="type">int</span> count, <span class="type">int</span> bit)</span>;   <span class="comment">//设置某一个位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_is_set</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> index)</span>; <span class="comment">//判断某个位置零或置一</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span>;   <span class="comment">//连续分配多个指定位</span></span><br></pre></td></tr></table></figure>
<p>bitmap_alloc_nbits函数传入的是想要将其反转的位，比如想找到连续的几个0置为1，函数中要传入0而不是1。所以实现起来也不是很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitmap_alloc_nbits</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">int</span> bit, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> search_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ok_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (search_idx &lt; bitmap-&gt;bit_count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx) != bit)</span><br><span class="line">        &#123;</span><br><span class="line">            search_idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ok_idx = search_idx;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; count) &amp;&amp; (search_idx &lt; bitmap-&gt;bit_count); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap_get_bit(bitmap, search_idx++) != bit)</span><br><span class="line">            &#123;</span><br><span class="line">                ok_idx = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= count)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap_set_bit(bitmap, ok_idx, count, ~bit);</span><br><span class="line">            <span class="keyword">return</span> ok_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地址分配器"><a href="#地址分配器" class="headerlink" title="地址分配器"></a>地址分配器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">addr_alloc_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">mutex_t</span> mutex;   <span class="comment">// 地址分配互斥信号量</span></span><br><span class="line">    <span class="type">bitmap_t</span> bitmap; <span class="comment">// 分配用的位图</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> page_size; <span class="comment">// 页大小</span></span><br><span class="line">    <span class="type">uint32_t</span> start;     <span class="comment">// 起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> size;      <span class="comment">// 地址大小</span></span><br><span class="line">&#125; <span class="type">addr_alloc_t</span>;</span><br></pre></td></tr></table></figure>
<p>地址分配器存放了需要分配的内存的起始地址、大小等信息，并为其分配了一个位图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addr_alloc_init</span><span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">uint8_t</span> *bits,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> page_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex_init(&amp;alloc-&gt;mutex);</span><br><span class="line">    alloc-&gt;start = start;</span><br><span class="line">    alloc-&gt;size = size;</span><br><span class="line">    alloc-&gt;page_size = page_size;</span><br><span class="line">    bitmap_init(&amp;alloc-&gt;bitmap, bits, alloc-&gt;size / page_size, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">addr_alloc_page</span><span class="params">(<span class="type">addr_alloc_t</span> *alloc, <span class="type">int</span> page_count)</span>    <span class="comment">//分配内存页</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;alloc-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> page_index = bitmap_alloc_nbits(&amp;alloc-&gt;bitmap, <span class="number">0</span>, page_count);</span><br><span class="line">    <span class="keyword">if</span> (page_index &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = alloc-&gt;start + page_index * alloc-&gt;page_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;alloc-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这些函数只能计算出分配地址的数值，并没有向对应的内存中写入任何数据。位图怎么和分配内存页配套使用呢？位图记录了一个内存页是否被使用，我们找到连续的未分配的内存页之后，将对应的位图位设置为1并将找到的内存的首地址通过函数返回值的形式返回给调用者，这样就可以分配内存了。</p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>我们将1M以上地址处供进程使用，将内存分为页来分配内存空间。在内存初始化中，memory_init传入了bootinfo为参数，包含了磁盘信息(int 13H中断读取磁盘信息)。内存初始化时首先要将分配的内存对齐4KB，然后创建paddr_alloc并初始化，进行管理，位图放在bss段之后。这样就初始化完成了内存，并可以使用paddr_alloc进行管理。我们设计的操作系统是32位，内存地址空间一共有4GB，每个内存页是4KB大小，我们需要使用转换表将每个内存页映射到物理内存上，一个表项处理一页内存，所以表项数量是4GB&#x2F;4KB，每个表项是4字节，所以表的大小是4MB。但是一个4MB的表项大部分情况下会浪费空间，所以intel采用了二级页表的形式。<br><img src="/2025/02/25/virtual%20memory/2.jpg" alt="2.jpg"><br><img src="/2025/02/25/virtual%20memory/3.jpg" alt="3.jpg"><br>为了方便起见，我们采用了intel提供的另一种形式。采用这种方式需要打开CR4寄存器的PSE位。<br><img src="/2025/02/25/virtual%20memory/4.jpg" alt="4.jpg"></p>
<h4 id="开启内存分页"><a href="#开启内存分页" class="headerlink" title="开启内存分页"></a>开启内存分页</h4><p>开启内存分页时需要将第一个页表的地址写入CR3寄存器中，同时开启CR0寄存器的PG位。<br><img src="/2025/02/25/virtual%20memory/5.jpg" alt="5.jpg"><br>我们需要按照上表中的说明将第一个页表进行设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enable_page_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_P (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_PS (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_W (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PSE (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_PG (1 &lt;&lt; 31)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> page_dir[<span class="number">1024</span>] __attribute__((aligned(<span class="number">4096</span>))) = &#123;</span><br><span class="line">        [<span class="number">0</span>] = PDE_P | PDE_PS | PDE_W,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> cr4 = read_cr4();</span><br><span class="line">    write_cr4(cr4 | CR4_PSE);</span><br><span class="line">    write_cr3((<span class="type">uint32_t</span>)page_dir);</span><br><span class="line">    write_cr0(read_cr0() | CR0_PG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这个页表只是在loader中进行使用，进入内核后我们需要开启二级分页。在内核中创建新的页表的目的是是根据内核lds脚本中的设置，将其各处不同的区域进行映射到不同的权限下，例如代码和只读设置只读，其它设置成可读写。且所有这些内存区域都不能允许用户访问。所有这些功能都可使用页表完成。<br><img src="/2025/02/25/virtual%20memory/6.jpg" alt="6.jpg"><br><img src="/2025/02/25/virtual%20memory/7.jpg" alt="7.jpg"><br>按照这个表中的内容来设置表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">pde_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> present : <span class="number">1</span>;       <span class="comment">// 0 (P) Present; must be 1 to map a 4-KByte page</span></span><br><span class="line">        <span class="type">uint32_t</span> write_disable : <span class="number">1</span>; <span class="comment">// 1 (R/W) Read/write, if 0, writes may not be allowe</span></span><br><span class="line">        <span class="type">uint32_t</span> user_mode_acc : <span class="number">1</span>; <span class="comment">// 2 (U/S) if 0, user-mode accesses are not allowed t</span></span><br><span class="line">        <span class="type">uint32_t</span> write_through : <span class="number">1</span>; <span class="comment">// 3 (PWT) Page-level write-through</span></span><br><span class="line">        <span class="type">uint32_t</span> cache_disable : <span class="number">1</span>; <span class="comment">// 4 (PCD) Page-level cache disable</span></span><br><span class="line">        <span class="type">uint32_t</span> accessed : <span class="number">1</span>;      <span class="comment">// 5 (A) Accessed</span></span><br><span class="line">        <span class="type">uint32_t</span> : <span class="number">1</span>;               <span class="comment">// 6 Ignored;</span></span><br><span class="line">        <span class="type">uint32_t</span> ps : <span class="number">1</span>;            <span class="comment">// 7 (PS)</span></span><br><span class="line">        <span class="type">uint32_t</span> : <span class="number">4</span>;               <span class="comment">// 11:8 Ignored</span></span><br><span class="line">        <span class="type">uint32_t</span> phy_pt_addr : <span class="number">20</span>;  <span class="comment">// 高20位page table物理地址</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">pde_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">pte_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> present : <span class="number">1</span>;        <span class="comment">// 0 (P) Present; must be 1 to map a 4-KByte page</span></span><br><span class="line">        <span class="type">uint32_t</span> write_disable : <span class="number">1</span>;  <span class="comment">// 1 (R/W) Read/write, if 0, writes may not be allowe</span></span><br><span class="line">        <span class="type">uint32_t</span> user_mode_acc : <span class="number">1</span>;  <span class="comment">// 2 (U/S) if 0, user-mode accesses are not allowed t</span></span><br><span class="line">        <span class="type">uint32_t</span> write_through : <span class="number">1</span>;  <span class="comment">// 3 (PWT) Page-level write-through</span></span><br><span class="line">        <span class="type">uint32_t</span> cache_disable : <span class="number">1</span>;  <span class="comment">// 4 (PCD) Page-level cache disable</span></span><br><span class="line">        <span class="type">uint32_t</span> accessed : <span class="number">1</span>;       <span class="comment">// 5 (A) Accessed;</span></span><br><span class="line">        <span class="type">uint32_t</span> dirty : <span class="number">1</span>;          <span class="comment">// 6 (D) Dirty</span></span><br><span class="line">        <span class="type">uint32_t</span> pat : <span class="number">1</span>;            <span class="comment">// 7 PAT</span></span><br><span class="line">        <span class="type">uint32_t</span> global : <span class="number">1</span>;         <span class="comment">// 8 (G) Global</span></span><br><span class="line">        <span class="type">uint32_t</span> : <span class="number">3</span>;                <span class="comment">// Ignored</span></span><br><span class="line">        <span class="type">uint32_t</span> phy_page_addr : <span class="number">20</span>; <span class="comment">// 高20位物理地址</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">pte_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以将二级页表的PDE和PTE设置为一个联合体，并在相应字段填入对应的值。PDE为一级页表，PTE为二级页表。同样的将PDE的第一个表项设置到CR3寄存器中就可以开启分页机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">memory_map_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *vstart; <span class="comment">// 虚拟地址</span></span><br><span class="line">    <span class="type">void</span> *vend;</span><br><span class="line">    <span class="type">void</span> *pstart;  <span class="comment">// 物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> perm; <span class="comment">// 访问权限</span></span><br><span class="line">&#125; <span class="type">memory_map_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kernel_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> s_text[], e_text[], s_data[], e_data[];<span class="comment">//在lds脚本中指示了各个段的开始和结束位置</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint8_t</span> kernel_base[];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">memory_map_t</span> kernel_map[] = &#123;</span><br><span class="line">        &#123;kernel_base, s_text, <span class="number">0</span>, PTE_W&#125;,                       <span class="comment">// 内核栈区</span></span><br><span class="line">        &#123;s_text, e_text, s_text, <span class="number">0</span>&#125;,                           <span class="comment">// 内核代码区</span></span><br><span class="line">        &#123;s_data, (<span class="type">void</span> *)(MEM_EBDA_START - <span class="number">1</span>), s_data, PTE_W&#125;, <span class="comment">// 内核数据区</span></span><br><span class="line">        &#123;(<span class="type">void</span> *)CONSOLE_DISP_ADDR, (<span class="type">void</span> *)(CONSOLE_DISP_END - <span class="number">1</span>), (<span class="type">void</span> *)CONSOLE_VIDEO_BASE, PTE_W&#125;,</span><br><span class="line">        &#123;(<span class="type">void</span> *)MEM_EXT_START, (<span class="type">void</span> *)MEM_EXT_END, (<span class="type">void</span> *)MEM_EXT_START, PTE_W&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空页目录表</span></span><br><span class="line">    kernel_memset(kernel_page_dir, <span class="number">0</span>, <span class="keyword">sizeof</span>(kernel_page_dir));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kernel_map) / <span class="keyword">sizeof</span>(<span class="type">memory_map_t</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">memory_map_t</span> *<span class="built_in">map</span> = kernel_map + i;</span><br><span class="line">        <span class="type">int</span> vstart = down2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vstart, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">int</span> vend = up2((<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;vend, MEM_PAGE_SIZE);</span><br><span class="line">        <span class="type">int</span> page_count = (vend - vstart) / MEM_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        memory_create_map(kernel_page_dir, vstart, (<span class="type">uint32_t</span>)<span class="built_in">map</span>-&gt;pstart, page_count, <span class="built_in">map</span>-&gt;perm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据figure4.2可知，pde的地址偏移量是虚拟地址的22-31位，pte的地址偏移量是虚拟地址的12-21位，前12位是地址的偏移量。关于figure4.2，GPT有详细的图解说明如下。（要结合Table 4.5,4.6）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1. 线性地址格式</span><br><span class="line">线性地址由CPU 生成，在开启分页机制后，它需要被转换成物理地址。线性地址由三部分组成：</span><br><span class="line"></span><br><span class="line">目录索引（Directory, 10位, 31~22位）：用于索引页目录中的页目录项（PDE）。</span><br><span class="line">表索引（Table, 10位, 21~12位）：用于索引页表中的页表项（PTE）。</span><br><span class="line">偏移量（Offset, 12位, 11~0位）：决定在最终物理页面中的位置。</span><br><span class="line">线性地址的结构如下：</span><br><span class="line"></span><br><span class="line">+------------+------------+------------+</span><br><span class="line">| Directory  |   Table    |   Offset   |</span><br><span class="line">|   (10b)    |   (10b)    |   (12b)    |</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">2. 线性地址到物理地址的转换过程</span><br><span class="line">分页机制采用两级页表映射，转换过程如下：</span><br><span class="line"></span><br><span class="line">（1）CR3寄存器</span><br><span class="line">CR3（控制寄存器3） 存储 页目录的物理地址（32位）。</span><br><span class="line">这个地址指向 页目录表（Page Directory），用于管理整个内存空间。</span><br><span class="line">（2）查找页目录（Page Directory）</span><br><span class="line">页目录存储多个PDE（页目录项），每个PDE占4字节（32位）。</span><br><span class="line">通过目录索引（Directory, 10位），选取页目录项（PDE）。</span><br><span class="line">PDE 指向 某个页表（Page Table） 的 物理地址。</span><br><span class="line">（3）查找页表（Page Table）</span><br><span class="line">页表存储多个PTE（页表项），每个PTE占4字节（32位）。</span><br><span class="line">通过表索引（Table, 10位），选取页表项（PTE）。</span><br><span class="line">PTE 指向 4KB物理页面的起始地址。</span><br><span class="line">（4）计算物理地址</span><br><span class="line">物理地址 = PTE提供的物理页基地址 + 偏移量（Offset, 12位）</span><br><span class="line">低12位的Offset用于索引4KB页面中的具体字节。</span><br><span class="line">3. 示例</span><br><span class="line">假设：</span><br><span class="line"></span><br><span class="line">CR3 = 0x00100000（指向页目录的物理地址）。</span><br><span class="line">线性地址 = 0x12345678：</span><br><span class="line">目录索引（Directory） = 0x12345678 &gt;&gt; 22 = 0x48</span><br><span class="line">表索引（Table） = 0x12345678 &gt;&gt; 12 &amp; 0x3FF = 0xD5</span><br><span class="line">偏移量（Offset） = 0x12345678 &amp; 0xFFF = 0x678</span><br><span class="line">转换过程：</span><br><span class="line"></span><br><span class="line">查找页目录项（PDE）：</span><br><span class="line"></span><br><span class="line">PDE 地址 = CR3 + (0x48 * 4) = 0x00100000 + 0x120 = 0x00100120</span><br><span class="line">PDE 指向的页表地址 = 0x00200000。</span><br><span class="line">查找页表项（PTE）：</span><br><span class="line"></span><br><span class="line">PTE 地址 = 0x00200000 + (0xD5 * 4) = 0x00200000 + 0x034 = 0x00200034</span><br><span class="line">PTE 指向的物理页地址 = 0x00345000。</span><br><span class="line">计算物理地址：</span><br><span class="line"></span><br><span class="line">物理地址 = 0x00345000 + 0x678 = 0x00345678。</span><br><span class="line">最终，线性地址 0x12345678 映射到 物理地址 0x00345678。</span><br><span class="line"></span><br><span class="line">4. 关键点总结</span><br><span class="line">分页机制采用两级页表结构：</span><br><span class="line"></span><br><span class="line">页目录（Page Directory）</span><br><span class="line">页表（Page Table）</span><br><span class="line">物理页面（Physical Page）</span><br><span class="line">CR3寄存器存储页目录的物理地址。</span><br><span class="line"></span><br><span class="line">地址转换的三步过程：</span><br><span class="line"></span><br><span class="line">页目录项（PDE） → 页表项（PTE） → 物理地址计算。</span><br><span class="line">最终的物理地址 由 PTE 指定的 4KB页面的起始地址 加上 12位偏移量 计算得到。</span><br><span class="line"></span><br><span class="line">这张图清晰地展示了32位操作系统（如x86架构）分页机制下的地址转换过程，用于虚拟内存管理和地址映射。</span><br></pre></td></tr></table></figure>
<p>根据上述描述，我们可以知道二级分页的基本转换关系了。在vaddr中取出高十位加上CR3寄存器中的值我们可以得到PDE的地址，找到PDE中的高20位加上vaddr中的12-21位就是PTE的地址，找到PTE的高二十位加上偏移量就是物理地址的值。理解这一点很关键，这一点是我们理解和编写后续代码所需要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memory_create_map</span><span class="params">(<span class="type">pde_t</span> *page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> paddr, <span class="type">int</span> count, <span class="type">uint32_t</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pte_t</span> *pte = find_pte(page_dir, vaddr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == (<span class="type">pte_t</span> *)<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ASSERT(pte-&gt;present == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        pte-&gt;v = paddr | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">        vaddr += MEM_PAGE_SIZE;</span><br><span class="line">        paddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是将指定的虚拟地址范围映射到物理地址空间，并为每个虚拟页面创建对应的页表项，是完成映射的一个核心函数。</p>
<h4 id="内存特权级处理"><a href="#内存特权级处理" class="headerlink" title="内存特权级处理"></a>内存特权级处理</h4><p>内核可以通过设置不同的页表权限位来建立内存保护机制，比如在内核代码区必须设置只读和可执行的权限，避免内核代码被恶意修改。对应的权限位可以查看Figure 4.6进行相应的配置。这样特权级隔离了之后用户程序访问内核代码会触发页错误。</p>
<h4 id="为进程分配页表"><a href="#为进程分配页表" class="headerlink" title="为进程分配页表"></a>为进程分配页表</h4><p>之前的文章中贴了一张TSS段的结构图，其中有一个CR3段，表明TSS段中可以存放页表的起始地址。我们打开分页机制后运行之前设置的两个进程，CPU会进行重启，原因就是我们还没有给进程分配相应的内存页。进程在进行切换时，CPU会读取TSS段中的CR3信息，将页表的起始地址放在CR3寄存器中。所以我们现在的任务是为创建好的进程分配内存页表。</p>
<p>初始化一个进程时，我们需要获取一页内存页传递到tss的cr3段中。现在我们采用的是二级页表结构，所以可以先分配一个PDE表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_create_uvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *page_dir = (<span class="type">pde_t</span> *)addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_memset((<span class="type">void</span> *)page_dir, <span class="number">0</span>, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> user_pde_start = pde_index(MEMORY_TASK_BASE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_pde_start; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        page_dir[i].v = kernel_page_dir[i].v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)page_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个函数为什么只分配了pde而没有分配pte，本人目前也没有太想清楚。分配好pde后将其和内核映射表对应起来，在创建进程的时候调用这个函数就可以分配页表了，这种设计使得所有用户进程都共享同一份内核地址空间映射。</p>
<h3 id="隔离内核与进程"><a href="#隔离内核与进程" class="headerlink" title="隔离内核与进程"></a>隔离内核与进程</h3><p>现在我们创建的两个进程在虚拟地址空间处是与内核混在一起的，代码也是和内核混在一起，现在我们要利用分页机制隔离内核与进程。第一个工作就是将代码从内核中分离，我们可以新建一个C文件将初始进程的代码放入其中来达到代码和内核进行分离的效果。接下来是虚拟地址空间的分离，并要将进程的物理地址放在kernel的后面，这个工作要在kerlen.lds中进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(在bss段之后)</span><br><span class="line">. = 0x80000000;</span><br><span class="line">.first_task : AT(e_data) &#123;</span><br><span class="line">		*first_task_entry*(.text .data. rodata .data)</span><br><span class="line">		*first_task*(.text .data. rodata .data)</span><br><span class="line">	&#125;</span><br><span class="line">(内核代码段加上)</span><br><span class="line">*(EXCLUDE_FILE(*first_task* *lib_syscall*).x)</span><br></pre></td></tr></table></figure>
<p>接下来是为进程分配内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">memory_alloc_for_page_dir</span><span class="params">(<span class="type">uint32_t</span> page_dir, <span class="type">uint32_t</span> vaddr, <span class="type">uint32_t</span> size, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> curr_vaddr = vaddr;</span><br><span class="line">    <span class="type">int</span> page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;</span><br><span class="line">    vaddr = down2(vaddr, MEM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐页分配内存，然后建立映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> paddr = addr_alloc_page(&amp;paddr_alloc, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (paddr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;mem alloc failed. no memory&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> err = memory_create_map((<span class="type">pde_t</span> *)page_dir, curr_vaddr, paddr, <span class="number">1</span>, perm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log_printf(<span class="string">&quot;create memory map failed. err = %d&quot;</span>, err);</span><br><span class="line">            addr_free_page(&amp;paddr_alloc, vaddr, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr_vaddr += MEM_PAGE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数可以完成物理页的分配并将其映射到0x80000000（进程空间）以上的区域。</p>
<h4 id="调整特权级"><a href="#调整特权级" class="headerlink" title="调整特权级"></a>调整特权级</h4><p>x86架构有四种特权级，ring0-ring3，其中0为最高特权级，3为最低特权级。3特权级无法任意访问os内核的代码、开关中断、写磁盘等，这个功能可以防止进程恶意修改内核的代码。关于权限的配置位如下：<br><img src="/2025/02/25/virtual%20memory/8.jpg" alt="8.jpg"><br>通过CS段寄存器最低两位表示当前执行代码的特权级（CPL）。访问数据时，DS、ES、FS、GS等段寄存器中的选择子包含RPL（请求特权级），段描述符中的DPL（描述符特权级）表示段存储空间的访问权限。CPU会检查CPL、RPL和DPL，确保访问权限匹配。访问数据段时当且仅当DPL&gt;&#x3D;Max(CPL,RPL)时才能访问，访问SS时要求CPL&#x3D;RPL&#x3D;DPL。每个内存页都有一个保护位U&#x2F;S，U&#x2F;S为0时只能被操作系统(CPL&#x3D;0,1,2)所访问，U&#x2F;S&#x3D;1时可以被应用程序所访问。<br><img src="/2025/02/25/virtual%20memory/9.jpg" alt="9.jpg"><br>在task中添加特权级字段，初始化时对tss进行判断，分别设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag &amp; TASK_FLAG_SYSTEM)</span><br><span class="line">    &#123;</span><br><span class="line">        code_sel = KERNEL_SELECTOR_CS;</span><br><span class="line">        data_sel = KERNEL_SELECTOR_DS;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        code_sel = task_manager.app_code_sel | SEG_RPL3;</span><br><span class="line">        data_sel = task_manager.app_data_sel | SEG_RPL3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="高特权级切换到低特权级"><a href="#高特权级切换到低特权级" class="headerlink" title="高特权级切换到低特权级"></a>高特权级切换到低特权级</h4><p>高特权级切换到低特权级需要用iret指令，同时还要向栈中压入一些变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">       <span class="string">&quot;push %[ss]\n\t&quot;</span>    </span><br><span class="line">       <span class="string">&quot;push %[esp]\n\t&quot;</span>    </span><br><span class="line">       <span class="string">&quot;push %[eflags]\n\t&quot;</span> </span><br><span class="line">       <span class="string">&quot;push %[cs]\n\t&quot;</span>    </span><br><span class="line">       <span class="string">&quot;push %[eip]\n\t&quot;</span>    </span><br><span class="line">       <span class="string">&quot;iret\n\t&quot;</span> ::[ss] <span class="string">&quot;r&quot;</span>(tss-&gt;ss),</span><br><span class="line">       [esp] <span class="string">&quot;r&quot;</span>(tss-&gt;esp), [eflags] <span class="string">&quot;r&quot;</span>(tss-&gt;eflags),</span><br><span class="line">       [cs] <span class="string">&quot;r&quot;</span>(tss-&gt;cs), [eip] <span class="string">&quot;r&quot;</span>(tss-&gt;eip));</span><br></pre></td></tr></table></figure>
<p>这样first task就可以切换到ring3。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/os/"># os</a>
                    
                        <a href="/tags/kernel/"># kernel</a>
                    
                        <a href="/tags/virtual-memory/"># virtual memory</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/04/16/sliding%20window/">sliding window</a>
            
            
            <a class="next" rel="next" href="/2024/12/10/pa1/">pa1</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© myslqyr | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>